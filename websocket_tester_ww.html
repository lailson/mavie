<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teste de WebSocket de Voz</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        h1 {
            color: #2c3e50;
        }
        .container {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
        }
        .button:hover {
            background-color: #2980b9;
        }
        .button.stop {
            background-color: #e74c3c;
        }
        .button.stop:hover {
            background-color: #c0392b;
        }
        .button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        #log {
            height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            margin-top: 20px;
            background-color: #fff;
        }
        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-left: 3px solid #3498db;
        }
        .log-error {
            border-left-color: #e74c3c;
            background-color: #fadbd8;
        }
        .log-success {
            border-left-color: #2ecc71;
            background-color: #d5f5e3;
        }
        .log-info {
            border-left-color: #f1c40f;
            background-color: #fef9e7;
        }
        .settings {
            margin: 20px 0;
            padding: 10px;
            background-color: #eaecee;
            border-radius: 4px;
        }
        .status {
            font-weight: bold;
            margin: 10px 0;
        }
        .status.connected {
            color: #27ae60;
        }
        .status.disconnected {
            color: #e74c3c;
        }
        audio {
            width: 100%;
            margin-top: 10px;
        }
        .transcript {
            background-color: #ebf5fb;
            padding: 10px;
            border-left: 4px solid #3498db;
            margin: 10px 0;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }
        
        .switch input { 
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: #2196F3;
        }
        
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        
        .silence-meter {
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .silence-bar {
            height: 100%;
            width: 0%;
            background-color: #4CAF50;
            border-radius: 10px;
            transition: width 0.1s;
        }

        /* Estilos para tooltip */
        .tooltip {
            position: relative;
            display: inline-block;
            margin-left: 5px;
            cursor: help;
        }
        
        .tooltip .tooltip-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            background-color: #3498db;
            color: white;
            border-radius: 50%;
            font-size: 12px;
            font-weight: bold;
        }
        
        .tooltip .tooltip-text {
            visibility: hidden;
            width: 300px;
            background-color: #34495e;
            color: white;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -150px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 14px;
            line-height: 1.4;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .tooltip .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #34495e transparent transparent transparent;
        }
        
        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Testador de WebSocket de Assistente de Voz</h1>
        
        <div class="settings">
            <h3>Configura√ß√µes</h3>
            <div>
                <label for="wsUrl">URL do WebSocket:</label>
                <input type="text" id="wsUrl" style="width: 90%;" 
                       value="wss://datalake-chat-dev.brazilsouth.cloudapp.azure.com/api-assistant/ws/conversation?doctor_id=205&language=pt-BR&output_format=mp3_44100">
            </div>
            <div style="margin-top: 10px;">
                <label for="chunkSize">Tamanho do chunk (ms):</label>
                <input type="number" id="chunkSize" min="50" max="500" value="100">
            </div>
            
            <!-- Configura√ß√µes de detec√ß√£o de sil√™ncio -->
            <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #ddd;">
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <label>Parar autom√°tico por sil√™ncio:</label>
                    <label class="switch">
                        <input type="checkbox" id="autoStopEnabled" checked>
                        <span class="slider"></span>
                    </label>
                </div>
                
                <!-- Adicionar configura√ß√£o de tempo m√°ximo de grava√ß√£o -->
                <div style="margin-top: 10px; display: flex; align-items: center;">
                    <label for="maxRecordingTime">Tempo m√°ximo de grava√ß√£o (segundos):</label>
                    <div class="tooltip">
                        <div class="tooltip-icon">?</div>
                        <span class="tooltip-text">
                            <strong>Tempo m√°ximo de grava√ß√£o</strong><br>
                            Define o tempo m√°ximo que a grava√ß√£o pode durar antes de parar automaticamente, independentemente do sil√™ncio.<br><br>
                            ‚Ä¢ <strong>0</strong>: Desabilita o limite de tempo (usa apenas detec√ß√£o de sil√™ncio)<br>
                            ‚Ä¢ <strong>3-10s</strong>: Bom para comandos curtos<br>
                            ‚Ä¢ <strong>15-30s</strong>: Para frases mais longas e consultas complexas<br><br>
                            A grava√ß√£o ser√° interrompida quando <em>qualquer</em> condi√ß√£o for atingida: sil√™ncio detectado OU tempo m√°ximo excedido.
                        </span>
                    </div>
                    <input type="number" id="maxRecordingTime" min="0" max="60" step="1" value="6" style="margin-left: 10px;">
                </div>
                
                <div style="margin-top: 10px; display: flex; align-items: center;">
                    <label for="silenceThreshold">Sensibilidade (0-100):</label>
                    <div class="tooltip">
                        <div class="tooltip-icon">?</div>
                        <span class="tooltip-text">
                            <strong>O que √© a sensibilidade?</strong><br>
                            Controla qu√£o sens√≠vel √© a detec√ß√£o de sil√™ncio:<br><br>
                            ‚Ä¢ <strong>Valores baixos (0-20)</strong>: Apenas sil√™ncio quase absoluto √© detectado. Ideal para ambientes quietos.<br>
                            ‚Ä¢ <strong>Valores m√©dios (20-50)</strong>: Detecta sil√™ncio mesmo com algum ru√≠do de fundo. Configura√ß√£o recomendada para a maioria dos ambientes.<br>
                            ‚Ä¢ <strong>Valores altos (50-100)</strong>: Mais sens√≠vel, pode interpretar sons baixos como sil√™ncio. Use em ambientes barulhentos quando quiser que a grava√ß√£o pare mesmo com algum ru√≠do.<br><br>
                            <em>Ajuste conforme o seu ambiente e sua voz.</em>
                        </span>
                    </div>
                    <input type="range" id="silenceThreshold" min="0" max="100" value="15" style="width: 60%; margin-left: 10px;">
                    <span id="thresholdValue">15</span>
                </div>
                <div style="margin-top: 10px; display: flex; align-items: center;">
                    <label for="silenceDuration">Dura√ß√£o do sil√™ncio (segundos):</label>
                    <div class="tooltip">
                        <div class="tooltip-icon">?</div>
                        <span class="tooltip-text">
                            <strong>Dura√ß√£o do sil√™ncio</strong><br>
                            Determina por quanto tempo o sil√™ncio deve ser detectado continuamente antes que a grava√ß√£o seja parada automaticamente.<br><br>
                            ‚Ä¢ <strong>Valores baixos (0.5-1s)</strong>: Resposta r√°pida, mas pode parar prematuramente se voc√™ fizer pausas naturais.<br>
                            ‚Ä¢ <strong>Valores m√©dios (1.5-2.5s)</strong>: Bom equil√≠brio, permite pausas breves na fala.<br>
                            ‚Ä¢ <strong>Valores altos (3s+)</strong>: Permite pausas maiores durante a fala sem interromper a grava√ß√£o.
                        </span>
                    </div>
                    <input type="number" id="silenceDuration" min="0.5" max="10" step="0.5" value="2" style="margin-left: 10px;">
                </div>
                <div style="margin-top: 10px;" id="silenceDetectionContainer">
                    <div>Status: <span id="silenceStatus">Aguardando grava√ß√£o</span></div>
                    <div class="silence-meter">
                        <div class="silence-bar" id="silenceBar"></div>
                    </div>
                </div>
                
                <!-- Adicionar indicador de tempo de grava√ß√£o -->
                <div style="margin-top: 10px; display: none;" id="recordingTimerContainer">
                    <div>Tempo de grava√ß√£o: <span id="recordingTime">0.0s</span> / <span id="maxRecordingTimeDisplay">6.0s</span></div>
                    <div class="silence-meter" style="background-color: #e0e0e0;">
                        <div class="silence-bar" id="recordingTimeBar" style="background-color: #3498db;"></div>
                    </div>
                </div>
            </div>
        </div>

        <div>
            <div class="status disconnected" id="status">Desconectado</div>
            <!-- Escondendo os bot√µes de conectar/desconectar, pois suas funcionalidades ser√£o integradas -->
            <button id="connectBtn" class="button" style="display: none;">Conectar</button>
            <button id="disconnectBtn" class="button" style="display: none; background-color: #f39c12;">Desconectar</button>
            <button id="startBtn" class="button">Iniciar Grava√ß√£o</button>
            <button id="stopBtn" class="button stop" disabled>Parar Grava√ß√£o</button>
            <!-- Bot√£o de tom de teste removido -->
        </div>

        <div class="transcript" id="transcript" style="display: none;">
            <strong>Transcri√ß√£o:</strong>
            <div id="transcriptText"></div>
        </div>

        <div id="audioResponse" style="margin-top: 20px; display: none;">
            <h3>Resposta de √Åudio:</h3>
            <audio id="audioPlayer" controls></audio>
        </div>
        
        <h3>Log de eventos:</h3>
        <div id="log"></div>
    </div>

    <script>
        // Elementos da interface
        const wsUrlInput = document.getElementById('wsUrl');
        const chunkSizeInput = document.getElementById('chunkSize');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        // Remo√ß√£o da refer√™ncia ao bot√£o de teste
        const statusElement = document.getElementById('status');
        const logElement = document.getElementById('log');
        const transcriptDiv = document.getElementById('transcript');
        const transcriptText = document.getElementById('transcriptText');
        const audioResponse = document.getElementById('audioResponse');
        const audioPlayer = document.getElementById('audioPlayer');
        
        // Elementos de detec√ß√£o de sil√™ncio
        const autoStopEnabledCheckbox = document.getElementById('autoStopEnabled');
        const silenceThresholdInput = document.getElementById('silenceThreshold');
        const silenceDurationInput = document.getElementById('silenceDuration');
        const silenceStatusElement = document.getElementById('silenceStatus');
        const silenceBarElement = document.getElementById('silenceBar');
        const thresholdValueDisplay = document.getElementById('thresholdValue');

        // Elementos para tempo m√°ximo de grava√ß√£o
        const maxRecordingTimeInput = document.getElementById('maxRecordingTime');
        const recordingTimeElement = document.getElementById('recordingTime');
        const maxRecordingTimeDisplay = document.getElementById('maxRecordingTimeDisplay');
        const recordingTimeBar = document.getElementById('recordingTimeBar');
        const recordingTimerContainer = document.getElementById('recordingTimerContainer');

        // Vari√°veis globais
        let websocket = null;
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let audioContext = null;
        let audioQueue = [];
        let silenceDetector = null;
        let microphoneStream = null; // Armazenar a stream do microfone
        let microphonePermissionGranted = false; // Indicador de permiss√£o concedida
        
        // Arrays para acumular chunks de √°udio da resposta
        let responseAudioChunks = [];
        let isCollectingAudioChunks = false;
        let audioBufferCounter = 0;
        let audioResponseCounter = 0; // Contador para respostas de √°udio recebidas
        
        // Vari√°veis para detec√ß√£o de sil√™ncio
        let silenceDetectionEnabled = true;
        let silenceAnalyser = null;
        let silenceDetectionInterval = null;
        let consecutiveSilenceTime = 0;
        let lastSilenceCheckTime = 0;
        let isSilent = false;
        
        // Vari√°veis para controle de tempo de grava√ß√£o
        let recordingStartTime = 0;
        let recordingTimer = null;
        
        // Atualizar o valor exibido do threshold
        silenceThresholdInput.addEventListener('input', () => {
            thresholdValueDisplay.textContent = silenceThresholdInput.value;
        });
        
        // Atualizar o valor exibido do tempo m√°ximo quando alterado
        maxRecordingTimeInput.addEventListener('input', () => {
            maxRecordingTimeDisplay.textContent = `${maxRecordingTimeInput.value}.0s`;
        });
        
        // Configurar ou desativar a detec√ß√£o de sil√™ncio
        autoStopEnabledCheckbox.addEventListener('change', () => {
            silenceDetectionEnabled = autoStopEnabledCheckbox.checked;
            log(`Detec√ß√£o autom√°tica de sil√™ncio ${silenceDetectionEnabled ? 'ativada' : 'desativada'}`, 'info');
        });

        // Solicitar permiss√£o do microfone no in√≠cio
        async function requestMicrophonePermission() {
            // Verificar primeiro o status atual da permiss√£o
            const hasPermission = await checkMicrophonePermissionStatus();
            if (hasPermission) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    microphoneStream = stream;
                    microphonePermissionGranted = true;
                    log('‚úÖ Usando permiss√£o de microfone j√° concedida', 'success');
                    
                    // N√£o vamos mais parar os tracks, apenas silenciar para economizar recursos
                    stream.getAudioTracks().forEach(track => {
                        track.enabled = false; // Silencia o stream sem par√°-lo
                    });
                    
                    // Habilitar o bot√£o de iniciar grava√ß√£o ap√≥s obter a permiss√£o
                    startBtn.disabled = false;
                    
                    return true;
                } catch (error) {
                    log(`‚ùå Erro ao acessar o microfone mesmo com permiss√£o concedida: ${error.message}`, 'error');
                    return false;
                }
            }
            
            // Se n√£o tiver permiss√£o, continuar com o fluxo normal de solicita√ß√£o
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                microphoneStream = stream;
                microphonePermissionGranted = true;
                log('‚úÖ Permiss√£o do microfone concedida', 'success');
                
                // Mostrar dica sobre como salvar a permiss√£o permanentemente
                log('üí° Dica: Voc√™ pode conceder permiss√£o permanente atrav√©s das configura√ß√µes do navegador', 'info');
                
                // N√£o vamos mais parar os tracks, apenas silenciar para economizar recursos
                stream.getAudioTracks().forEach(track => {
                    track.enabled = false; // Silencia o stream sem par√°-lo
                });
                
                // Habilitar o bot√£o de iniciar grava√ß√£o ap√≥s obter a permiss√£o
                startBtn.disabled = false;
                
                return true;
            } catch (error) {
                log(`‚ùå Erro ao acessar o microfone: ${error.message}`, 'error');
                // Adicionar mensagem mais vis√≠vel sobre a necessidade do microfone
                const errorMsg = document.createElement('div');
                errorMsg.style.backgroundColor = '#ffebee';
                errorMsg.style.color = '#c62828';
                errorMsg.style.padding = '15px';
                errorMsg.style.margin = '15px 0';
                errorMsg.style.borderRadius = '4px';
                errorMsg.style.fontWeight = 'bold';
                errorMsg.innerHTML = `
                    <p>‚ùå Esta aplica√ß√£o requer acesso ao microfone para funcionar.</p>
                    <p>Por favor, conceda permiss√£o ao navegador e recarregue a p√°gina.</p>
                    <button id="retryPermissionBtn" class="button" style="background-color:#f44336; margin-top:10px;">Tentar Novamente</button>
                `;
                document.querySelector('.container').prepend(errorMsg);
                
                // Adicionar bot√£o para tentar novamente
                document.getElementById('retryPermissionBtn').addEventListener('click', async () => {
                    errorMsg.remove();
                    const granted = await requestMicrophonePermission();
                    if (granted) {
                        startBtn.disabled = false;
                    }
                });
                
                // Desabilitar bot√µes relevantes
                connectBtn.disabled = true;
                startBtn.disabled = true;
                
                return false;
            }
        }

        // Adicionar fun√ß√£o para verificar e gerenciar status das permiss√µes
        async function checkMicrophonePermissionStatus() {
            try {
                // Verificar se a API de permiss√µes √© suportada pelo navegador
                if (navigator.permissions && navigator.permissions.query) {
                    const permissionStatus = await navigator.permissions.query({ name: 'microphone' });
                    
                    // Mostrar instru√ß√µes apropriadas com base no status atual
                    if (permissionStatus.state === 'granted') {
                        log('‚úÖ Permiss√£o do microfone j√° est√° concedida permanentemente', 'success');
                        return true;
                    } else if (permissionStatus.state === 'prompt') {
                        // Mostrar instru√ß√µes sobre como permitir permanentemente
                        showPermanentPermissionInstructions();
                        return false;
                    } else if (permissionStatus.state === 'denied') {
                        log('‚ùå Permiss√£o do microfone foi negada. Por favor, reinicie as permiss√µes nas configura√ß√µes do navegador', 'error');
                        showPermissionResetInstructions();
                        return false;
                    }
                    
                    // Adicionar listener para mudan√ßas de status
                    permissionStatus.onchange = function() {
                        if (this.state === 'granted') {
                            log('‚úÖ Permiss√£o do microfone concedida permanentemente', 'success');
                        }
                    };
                }
            } catch (error) {
                console.error("Erro ao verificar status da permiss√£o:", error);
            }
            
            return false;
        }
        
        // Fun√ß√£o para mostrar instru√ß√µes sobre permiss√µes permanentes
        function showPermanentPermissionInstructions() {
            // Criar elemento de instru√ß√µes
            const instructionsDiv = document.createElement('div');
            instructionsDiv.style.padding = '15px';
            instructionsDiv.style.margin = '15px 0';
            instructionsDiv.style.backgroundColor = '#e3f2fd';
            instructionsDiv.style.borderLeft = '4px solid #2196F3';
            instructionsDiv.style.borderRadius = '4px';
            instructionsDiv.innerHTML = `
                <h3 style="margin-top:0">üìå Como conceder permiss√£o permanente do microfone</h3>
                <p>Para evitar ter que permitir o uso do microfone toda vez que abrir esta p√°gina:</p>
                <ol>
                    <li>Quando a solicita√ß√£o de microfone aparecer, clique no √≠cone de permiss√£o na barra de endere√ßos</li>
                    <li>Selecione "Permitir sempre" ou "Lembrar minha decis√£o"</li>
                    <li>Alguns navegadores podem precisar que voc√™ adicione este site aos sites confi√°veis</li>
                </ol>
                <p><strong>Dica:</strong> Se estiver usando o Chrome, voc√™ pode gerenciar as permiss√µes em: <code>chrome://settings/content/microphone</code></p>
                <p><strong>Dica:</strong> Se estiver usando o Firefox, voc√™ pode gerenciar as permiss√µes em: <code>about:preferences#privacy</code> na se√ß√£o Permiss√µes</p>
                <button id="dismissInstructionsBtn" class="button" style="background-color:#2196F3">Entendi</button>
            `;
            
            // Adicionar ao in√≠cio da p√°gina
            document.querySelector('.container').prepend(instructionsDiv);
            
            // Adicionar evento para fechar as instru√ß√µes
            document.getElementById('dismissInstructionsBtn').addEventListener('click', () => {
                instructionsDiv.style.display = 'none';
            });
        }
        
        // Fun√ß√£o para mostrar instru√ß√µes de reset quando permiss√£o foi negada
        function showPermissionResetInstructions() {
            const resetDiv = document.createElement('div');
            resetDiv.style.padding = '15px';
            resetDiv.style.margin = '15px 0';
            resetDiv.style.backgroundColor = '#ffebee';
            resetDiv.style.borderLeft = '4px solid #f44336';
            resetDiv.style.borderRadius = '4px';
            resetDiv.innerHTML = `
                <h3 style="margin-top:0">‚ö†Ô∏è Permiss√£o de microfone bloqueada</h3>
                <p>Voc√™ bloqueou anteriormente a permiss√£o do microfone para este site. Para usar esta aplica√ß√£o:</p>
                
                <h4>No Chrome:</h4>
                <ol>
                    <li>Clique no √≠cone de cadeado üîí na barra de endere√ßos</li>
                    <li>Encontre "Microfone" e selecione "Permitir"</li>
                    <li>Recarregue a p√°gina</li>
                </ol>
                
                <h4>No Firefox:</h4>
                <ol>
                    <li>Clique no √≠cone de permiss√µes (üõ°Ô∏è ou ‚ìò) na barra de endere√ßos</li>
                    <li>Clique em "Remover permiss√£o" ou selecione "Permitir"</li>
                    <li>Recarregue a p√°gina</li>
                </ol>
                
                <h4>No Safari:</h4>
                <ol>
                    <li>Clique em Safari > Prefer√™ncias > Websites > Microfone</li>
                    <li>Encontre este website e altere a permiss√£o</li>
                    <li>Recarregue a p√°gina</li>
                </ol>
                
                <h4>No Edge:</h4>
                <ol>
                    <li>Clique no √≠cone de cadeado üîí na barra de endere√ßos</li>
                    <li>Encontre "Microfone" e selecione "Permitir"</li>
                    <li>Recarregue a p√°gina</li>
                </ol>
                
                <button id="reloadPageBtn" class="button" style="background-color:#f44336">Recarregar P√°gina</button>
            `;
            
            // Adicionar ao in√≠cio da p√°gina
            document.querySelector('.container').prepend(resetDiv);
            
            // Adicionar evento para recarregar a p√°gina
            document.getElementById('reloadPageBtn').addEventListener('click', () => {
                location.reload();
            });
        }

        // Adicionar mensagem ao log
        function log(message, type = 'normal') {
            // Verificar se o usu√°rio est√° no fim do log antes de adicionar novo conte√∫do
            const isScrolledToBottom = logElement.scrollHeight - logElement.clientHeight <= logElement.scrollTop + 5;
            
            const entry = document.createElement('div');
            entry.classList.add('log-entry');
            if (type !== 'normal') {
                entry.classList.add(`log-${type}`);
            }
            
            const timestamp = new Date().toLocaleTimeString();
            entry.innerHTML = `<strong>${timestamp}</strong>: ${message}`;
            
            logElement.appendChild(entry);
            
            // Rolar para o fim apenas se o usu√°rio j√° estava no fim do log
            if (isScrolledToBottom) {
                logElement.scrollTop = logElement.scrollHeight;
            }
        }

        // Adicionar vari√°veis para o buffer de √°udio
        let audioBuffer = [];
        let isWebSocketConnected = false;
        let isBufferingAudio = false;

        // Fun√ß√£o para conectar ao WebSocket e iniciar grava√ß√£o
        function connectAndStartRecording() {
            const wsUrl = wsUrlInput.value.trim();
            if (!wsUrl) {
                log('URL do WebSocket n√£o pode estar vazia', 'error');
                return;
            }

            try {
                // Desabilitar o bot√£o de iniciar para evitar m√∫ltiplos cliques
                startBtn.disabled = true;
                
                // Sempre fechar qualquer conex√£o anterior para garantir uma nova conex√£o
                if (websocket) {
                    log('Fechando conex√£o WebSocket existente antes de criar nova...', 'info');
                    try { 
                        if (websocket.readyState === WebSocket.OPEN || websocket.readyState === WebSocket.CONNECTING) {
                            websocket.close(1000, "Nova grava√ß√£o iniciada"); 
                        }
                    } catch (e) { 
                        log(`Erro ao fechar conex√£o existente: ${e.message}`, 'error');
                    }
                    websocket = null;
                }
                
                // Limpar o buffer de √°udio
                audioBuffer = [];
                isWebSocketConnected = false;
                
                // Iniciar grava√ß√£o imediatamente (ir√° armazenar em buffer)
                isBufferingAudio = true;
                log('Iniciando captura de √°udio enquanto estabelece conex√£o...', 'info');
                startRecording();
                
                // Criar nova conex√£o WebSocket (com um pequeno delay para garantir que a conex√£o anterior foi fechada)
                setTimeout(() => {
                    log('Estabelecendo nova conex√£o WebSocket...', 'info');
                    
                    websocket = new WebSocket(wsUrl);
                    
                    websocket.onopen = (event) => {
                        statusElement.textContent = 'Conectado';
                        statusElement.classList.remove('disconnected');
                        statusElement.classList.add('connected');
                        log('‚úÖ Conex√£o WebSocket estabelecida com sucesso', 'success');
                        
                        // Marcar que a conex√£o est√° pronta
                        isWebSocketConnected = true;
                        
                        // Enviar todos os chunks armazenados no buffer
                        if (audioBuffer.length > 0) {
                            log(`Enviando ${audioBuffer.length} chunks armazenados em buffer...`, 'info');
                            audioBuffer.forEach((chunk, index) => {
                                websocket.send(chunk);
                                if (index === 0) {
                                    log(`‚úÖ PRIMEIRO CHUNK enviado do buffer (${(chunk.size/1024).toFixed(2)} KB) - Cont√©m header!`, 'success');
                                }
                            });
                            log(`Buffer de √°udio enviado com sucesso.`, 'success');
                            audioBuffer = []; // Limpar o buffer
                        }
                        
                        isBufferingAudio = false;
                    };

                    websocket.onmessage = (event) => {
                        console.log("Mensagem recebida:", event.data);
                        log(`Mensagem recebida do servidor (tipo: ${typeof event.data})`, 'info');
                        
                        if (event.data instanceof Blob) {
                            log(`‚úÖ Recebido chunk de √°udio: ${event.data.size} bytes`, 'success');
                            
                            // Iniciar coleta de chunks se ainda n√£o estiver coletando
                            if (!isCollectingAudioChunks) {
                                isCollectingAudioChunks = true;
                                responseAudioChunks = []; // Limpar array anterior
                                log("Iniciando coleta de chunks de √°udio para resposta completa...", "info");
                            }
                            
                            // Adicionar o chunk ao array de resposta
                            responseAudioChunks.push(event.data);
                            log(`Chunk de √°udio #${responseAudioChunks.length} armazenado (${event.data.size} bytes)`, 'info');
                        } else {
                            // Resposta de texto/JSON
                            try {
                                const jsonData = JSON.parse(event.data);
                                log(`Dados JSON recebidos: ${JSON.stringify(jsonData).substring(0, 100)}...`, 'info');
                                
                                // Se recebeu a resposta final JSON com conversation_id, finalizar a coleta de √°udio
                                if (jsonData.conversation_id) {
                                    if (isCollectingAudioChunks) {
                                        log(`‚úÖ Recebida resposta final. Reproduzindo ${responseAudioChunks.length} chunks de √°udio acumulados...`, 'success');
                                        // Processar e reproduzir todos os chunks acumulados
                                        processAndPlayCombinedAudio();
                                        isCollectingAudioChunks = false;
                                    }
                                }
                                
                                handleJsonResponse(jsonData);
                                
                                // Quando reconhece a fala completa, apenas logamos, sem enviar pings
                                if (jsonData.recognized) {
                                    log("Fala reconhecida! Aguardando resposta de √°udio...", 'info');
                                }
                            } catch (e) {
                                log(`Mensagem texto recebida: ${event.data}`, 'info');
                            }
                        }
                    };

                    websocket.onclose = (event) => {
                        statusElement.textContent = 'Desconectado';
                        statusElement.classList.remove('connected');
                        statusElement.classList.add('disconnected');
                        stopBtn.disabled = true;
                        startBtn.disabled = false;
                        
                        log(`Conex√£o fechada: ${event.code} ${event.reason}`, 'info');
                        websocket = null;
                    };

                    websocket.onerror = (error) => {
                        log(`‚ùå Erro na conex√£o WebSocket: ${error}`, 'error');
                        startBtn.disabled = false;
                        isWebSocketConnected = false;
                    };
                }, 300); // pequeno delay para garantir que a conex√£o anterior foi fechada

            } catch (error) {
                log(`Erro ao iniciar processo: ${error.message}`, 'error');
                startBtn.disabled = false;
                isBufferingAudio = false;
            }
        }
        
        // Fun√ß√£o para iniciar a grava√ß√£o
        async function startRecording() {
            if (isRecording) return;
            
            try {
                // Verificar permiss√£o do microfone
                if (!microphonePermissionGranted) {
                    const permissionGranted = await requestMicrophonePermission();
                    if (!permissionGranted) {
                        log('N√£o foi poss√≠vel iniciar a grava√ß√£o sem permiss√£o do microfone', 'error');
                        return;
                    }
                }
                
                // Mesmo que o bot√£o de iniciar esteja desabilitado para evitar cliques m√∫ltiplos,
                // vamos garantir que o bot√£o de parar esteja dispon√≠vel
                stopBtn.disabled = false;
                
                // Reutilizar a stream existente se dispon√≠vel, ou obter uma nova se necess√°rio
                let stream;
                if (microphoneStream && microphoneStream.active) {
                    stream = microphoneStream;
                    // Reativar as tracks de √°udio que foram silenciadas
                    stream.getAudioTracks().forEach(track => {
                        track.enabled = true;
                    });
                    log('Reutilizando permiss√£o de microfone j√° concedida', 'success');
                } else {
                    // Se a stream n√£o estiver mais ativa, obter uma nova
                    stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    microphoneStream = stream;
                    log('Nova stream de microfone obtida', 'info');
                }
                
                // Configurar o MediaRecorder
                const chunkSize = parseInt(chunkSizeInput.value) || 100;
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm',
                });
                
                // Contador para monitorar os chunks
                let chunkCounter = 0;
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        chunkCounter++;
                        
                        // Se estamos em modo buffer ou o WebSocket n√£o est√° conectado,
                        // armazenar o chunk no buffer
                        if (isBufferingAudio || !isWebSocketConnected) {
                            audioBuffer.push(event.data);
                            
                            // Log especial para o primeiro chunk (cont√©m header)
                            if (chunkCounter === 1) {
                                log(`üîç Primeiro chunk capturado (${(event.data.size/1024).toFixed(2)} KB) - Armazenado em buffer`, 'info');
                            } else if (chunkCounter % 5 === 0) {
                                log(`Armazenando chunk #${chunkCounter} em buffer (${audioBuffer.length} chunks no total)`, 'info');
                            }
                        } 
                        // Se o WebSocket est√° conectado e n√£o estamos em modo buffer, enviar diretamente
                        else if (websocket && websocket.readyState === WebSocket.OPEN) {
                            websocket.send(event.data);
                            
                            if (chunkCounter % 5 === 0) {
                                log(`Chunk #${chunkCounter} enviado diretamente (${(event.data.size/1024).toFixed(2)} KB)`, 'info');
                            }
                        }
                    }
                };
                
                mediaRecorder.onstop = () => {
                    log('Grava√ß√£o finalizada', 'info');
                    isRecording = false;
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                    isBufferingAudio = false;
                };
                
                // Iniciar grava√ß√£o com timeslice para chunks
                mediaRecorder.start(chunkSize);
                
                // Iniciar o status de grava√ß√£o
                isRecording = true;
                log('Grava√ß√£o iniciada', 'success');
                
                // Iniciar detec√ß√£o de sil√™ncio se estiver habilitada
                if (silenceDetectionEnabled) {
                    startSilenceDetection(stream);
                }
                
                // Iniciar o timer de grava√ß√£o
                startRecordingTimer();
                
            } catch (error) {
                log(`Erro ao acessar o microfone: ${error.message}`, 'error');
                microphonePermissionGranted = false;
                microphoneStream = null;
                startBtn.disabled = false;
                stopBtn.disabled = true;
                isBufferingAudio = false;
            }
        }
        
        // Fun√ß√£o para parar grava√ß√£o e desconectar
        function stopRecordingAndDisconnect() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                
                // N√£o parar completamente os tracks, apenas silenciar
                if (microphoneStream) {
                    microphoneStream.getAudioTracks().forEach(track => {
                        track.enabled = false; // Silencia sem parar
                    });
                }
                
                // Parar detec√ß√£o de sil√™ncio
                stopSilenceDetection();
                
                // Parar timer de grava√ß√£o
                stopRecordingTimer();
                
                isRecording = false;
                startBtn.disabled = false;
                stopBtn.disabled = true;
                isBufferingAudio = false;
                
                log('Grava√ß√£o interrompida', 'info');
                
                // Limpar buffer de √°udio, n√£o √© mais necess√°rio
                if (audioBuffer.length > 0) {
                    log(`Descartando ${audioBuffer.length} chunks em buffer`, 'info');
                    audioBuffer = [];
                }
                
                // Desconectar o WebSocket
                if (websocket && websocket.readyState === WebSocket.OPEN) {
                    log('Desconectando do WebSocket...', 'info');
                    
                    try {
                        websocket.close(1000, "Desconex√£o solicitada pelo usu√°rio");
                        isWebSocketConnected = false;
                    } catch (error) {
                        log(`Erro ao desconectar: ${error.message}`, 'error');
                    }
                }
            }
        }

        // Fun√ß√£o para parar grava√ß√£o (compartilhada pelo bot√£o e pela detec√ß√£o autom√°tica)
        function stopRecording() {
            if (mediaRecorder && isRecording) {
                mediaRecorder.stop();
                
                // N√£o parar completamente os tracks, apenas silenciar
                if (microphoneStream) {
                    microphoneStream.getAudioTracks().forEach(track => {
                        track.enabled = false; // Silencia sem parar
                    });
                }
                
                // Parar detec√ß√£o de sil√™ncio
                stopSilenceDetection();
                
                // Parar timer de grava√ß√£o
                stopRecordingTimer();
                
                log('Grava√ß√£o interrompida, mas conex√£o mantida para receber respostas', 'info');
                log('Aguardando resposta do servidor...', 'info');
            }
        }

        // Modificar os listeners de evento para os bot√µes
        startBtn.addEventListener('click', () => {
            // Agora o bot√£o de iniciar sempre tenta conectar primeiro
            connectAndStartRecording();
        });
        
        stopBtn.addEventListener('click', () => {
            // Agora o bot√£o de parar tamb√©m desconecta
            stopRecordingAndDisconnect();
        });

        // Processar resposta JSON
        function handleJsonResponse(data) {
            if (data.recognizing) {
                transcriptDiv.style.display = 'block';
                transcriptText.textContent = data.recognizing;
                log(`Reconhecendo: "${data.recognizing}"`, 'info');
            } 
            else if (data.recognized) {
                transcriptDiv.style.display = 'block';
                transcriptText.textContent = data.recognized;
                log(`Reconhecido: "${data.recognized}"`, 'success');
                
                // Quando uma transcri√ß√£o completa √© reconhecida, informar ao usu√°rio para aguardar a resposta em √°udio
                log('Transcri√ß√£o completa! Aguardando resposta de √°udio...', 'info');
            }
            else if (data.conversation_id) {
                log(`Resposta final recebida: "${data.assistant_message.content}"`, 'success');
                
                // Exibir resposta textual de forma mais proeminente
                const responseDisplay = document.createElement('div');
                responseDisplay.style.padding = '15px';
                responseDisplay.style.margin = '10px 0';
                responseDisplay.style.backgroundColor = '#d5f5e3';
                responseDisplay.style.borderLeft = '4px solid #2ecc71';
                responseDisplay.style.borderRadius = '4px';
                responseDisplay.innerHTML = `<strong>Resposta do assistente:</strong><br>${data.assistant_message.content}`;
                
                // Inserir antes do log
                document.querySelector('.container').insertBefore(responseDisplay, document.querySelector('h3').nextSibling);
            }
            else {
                log(`Resposta JSON: ${JSON.stringify(data)}`, 'info');
            }
            
            // Remo√ß√£o do c√≥digo que adiciona o bot√£o "Enviar sil√™ncio para estimular resposta"
        }

        // Remover a fun√ß√£o sendNullSound() que n√£o ser√° mais utilizada

        // Fun√ß√£o para processar e reproduzir os chunks de √°udio combinados
        function processAndPlayCombinedAudio() {
            if (!responseAudioChunks.length) {
                log("Nenhum chunk de √°udio para processar", "error");
                return;
            }
            
            log(`Combinando ${responseAudioChunks.length} chunks de √°udio em um √∫nico arquivo...`, "info");
            
            // Incrementar o contador de respostas de √°udio
            audioResponseCounter++;
            
            // Combinar todos os chunks em um √∫nico Blob
            const combinedBlob = new Blob(responseAudioChunks, { type: 'audio/mp3' });
            log(`√Åudio combinado criado: ${(combinedBlob.size/1024).toFixed(2)} KB total`, "success");
            
            // Criar URL para o blob combinado
            const audioUrl = URL.createObjectURL(combinedBlob);
            
            // Atualizar o player de √°udio
            audioResponse.style.display = 'block';
            
            // Primeiro remover elementos antigos
            const existingButtons = audioResponse.querySelectorAll('button, a');
            existingButtons.forEach(el => el.remove());
            
            // Criar um novo elemento de √°udio
            const oldAudio = document.getElementById('audioPlayer');
            const newAudio = document.createElement('audio');
            newAudio.id = 'audioPlayer';
            newAudio.controls = true;
            oldAudio.parentNode.replaceChild(newAudio, oldAudio);
            
            // Remover div de controles anterior antes de adicionar uma nova
            const oldControlsDiv = document.querySelector('.audio-controls-container');
            if (oldControlsDiv) {
                oldControlsDiv.remove();
            }
            
            // Adicionar bot√£o de download
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'audio-controls-container'; 
            controlsDiv.style.margin = '15px 0';
            controlsDiv.style.padding = '10px';
            controlsDiv.style.backgroundColor = '#f1f8e9';
            controlsDiv.style.borderRadius = '8px';
            controlsDiv.style.textAlign = 'center';
            
            const downloadLink = document.createElement('a');
            downloadLink.href = audioUrl;
            downloadLink.download = `resposta_completa_${new Date().toISOString().replace(/[:.]/g, '_')}.mp3`;
            downloadLink.className = 'button';
            downloadLink.style.display = 'inline-block';
            downloadLink.innerHTML = 'üíæ Baixar MP3';
            
            // Adicionar os elementos √† p√°gina
            controlsDiv.appendChild(downloadLink);
            audioResponse.insertBefore(controlsDiv, document.getElementById('audioPlayer'));
            
            // Reproduzir o √°udio automaticamente
            const playerElement = document.getElementById('audioPlayer');
            playerElement.src = audioUrl;
            log('üîä Iniciando reprodu√ß√£o autom√°tica do √°udio...', 'success');
            
            // Tentar diferentes abordagens para garantir a reprodu√ß√£o
            setTimeout(() => {
                playerElement.load();
                const playPromise = playerElement.play();
                
                if (playPromise !== undefined) {
                    playPromise
                        .then(() => log('‚ñ∂Ô∏è Reprodu√ß√£o iniciada com sucesso!', 'success'))
                        .catch(e => {
                            log(`‚ùå Erro na reprodu√ß√£o autom√°tica: ${e.message}. Pol√≠ticas do navegador podem estar bloqueando.`, 'error');
                            
                            // Criar um bot√£o de reprodu√ß√£o manual caso falhe
                            const playButton = document.createElement('button');
                            playButton.className = 'button';
                            playButton.style.backgroundColor = '#4CAF50';
                            playButton.style.marginRight = '10px';
                            playButton.innerHTML = '‚ñ∂Ô∏è Clique para reproduzir';
                            playButton.onclick = () => playerElement.play();
                            
                            controlsDiv.insertBefore(playButton, downloadLink);
                        });
                }
            }, 100);
            
            // Remover notifica√ß√µes antigas de √°udio recebido
            const existingNotifications = document.querySelectorAll('.audio-response-notification');
            existingNotifications.forEach(notification => notification.remove());
            
            // Mostrar notifica√ß√£o com contador
            const notification = document.createElement('div');
            notification.className = 'audio-response-notification';
            notification.style.padding = '15px';
            notification.style.backgroundColor = '#e3f2fd';
            notification.style.border = '2px solid #2196F3';
            notification.style.borderRadius = '8px';
            notification.style.margin = '20px 0';
            notification.style.textAlign = 'center';
            notification.innerHTML = `
                <h3 style="color:#0d47a1; margin:0;">üîî Resposta de √Åudio #${audioResponseCounter} Recebida!</h3>
                <p style="margin:10px 0;">Reprodu√ß√£o autom√°tica iniciada</p>
            `;
            
            // Verificar se h√° algum elemento com classe 'transcript'
            const transcriptElement = document.querySelector('.transcript');
            if (transcriptElement) {
                document.querySelector('.container').insertBefore(
                    notification, 
                    transcriptElement.nextSibling
                );
            } else {
                // Se n√£o houver, inserir antes do log
                document.querySelector('.container').insertBefore(
                    notification, 
                    document.querySelector('h3')
                );
            }
            
            log(`‚úÖ √Åudio #${audioResponseCounter} carregado e reprodu√ß√£o autom√°tica iniciada`, 'success');
        }

        // Fun√ß√£o para iniciar a detec√ß√£o de sil√™ncio
        function startSilenceDetection(stream) {
            if (!silenceDetectionEnabled) return;
            
            // Criar contexto de √°udio se n√£o existir
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            // Criar analisador para detec√ß√£o de sil√™ncio
            const source = audioContext.createMediaStreamSource(stream);
            silenceAnalyser = audioContext.createAnalyser();
            silenceAnalyser.fftSize = 256;
            source.connect(silenceAnalyser);
            const bufferLength = silenceAnalyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            
            // Iniciar o intervalo de detec√ß√£o de sil√™ncio
            consecutiveSilenceTime = 0;
            lastSilenceCheckTime = Date.now();
            
            silenceDetectionInterval = setInterval(() => {
                if (!isRecording || !silenceDetectionEnabled) return;
                
                // Obter dados de √°udio para an√°lise
                silenceAnalyser.getByteFrequencyData(dataArray);
                
                // Calcular o volume m√©dio (0-255)
                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    sum += dataArray[i];
                }
                const average = sum / bufferLength;
                
                // Normalizar para uma escala de 0-100
                const normalizedValue = Math.min(100, Math.max(0, average / 2.55));
                
                // Atualizar a barra visual
                silenceBarElement.style.width = `${normalizedValue}%`;
                silenceBarElement.style.backgroundColor = normalizedValue > silenceThresholdInput.value 
                    ? '#FF9800' // Laranja quando h√° som
                    : '#4CAF50'; // Verde quando √© sil√™ncio
                
                // Verificar se est√° em sil√™ncio (abaixo do limiar configurado)
                const currentTime = Date.now();
                const elapsedMs = currentTime - lastSilenceCheckTime;
                lastSilenceCheckTime = currentTime;
                
                const thresholdValue = parseFloat(silenceThresholdInput.value);
                const currentlyIsSilent = normalizedValue <= thresholdValue;
                
                // Atualizar status
                silenceStatusElement.textContent = currentlyIsSilent 
                    ? `Sil√™ncio detectado (${(consecutiveSilenceTime / 1000).toFixed(1)}s)` 
                    : 'Voz detectada';
                silenceStatusElement.style.color = currentlyIsSilent ? '#4CAF50' : '#FF9800';
                
                if (currentlyIsSilent) {
                    // Incrementar contador de sil√™ncio consecutivo
                    consecutiveSilenceTime += elapsedMs;
                    
                    // Verificar se atingiu o tempo de sil√™ncio configurado
                    const silenceDurationMs = parseFloat(silenceDurationInput.value) * 1000;
                    if (consecutiveSilenceTime >= silenceDurationMs) {
                        log(`Sil√™ncio detectado por ${silenceDurationInput.value} segundos. Parando grava√ß√£o automaticamente.`, 'info');
                        stopRecording();
                    }
                } else {
                    // Resetar contador se detectou som
                    consecutiveSilenceTime = 0;
                }
            }, 100); // Verificar a cada 100ms
            
            log('Detec√ß√£o de sil√™ncio iniciada', 'info');
        }

        // Fun√ß√£o para parar a detec√ß√£o de sil√™ncio
        function stopSilenceDetection() {
            if (silenceDetectionInterval) {
                clearInterval(silenceDetectionInterval);
                silenceDetectionInterval = null;
            }
            silenceStatusElement.textContent = 'Aguardando grava√ß√£o';
            silenceStatusElement.style.color = '';
        }

        // Fun√ß√£o para iniciar o timer de grava√ß√£o
        function startRecordingTimer() {
            recordingStartTime = Date.now();
            recordingTimerContainer.style.display = 'block';
            // Atualizar display inicial
            recordingTimeElement.textContent = '0.0s';
            maxRecordingTimeDisplay.textContent = `${maxRecordingTimeInput.value}.0s`;
            recordingTimeBar.style.width = '0%';
            
            // Configurar timer para atualiza√ß√£o cont√≠nua
            recordingTimer = setInterval(() => {
                if (!isRecording) {
                    clearInterval(recordingTimer);
                    return;
                }
                
                const elapsedSeconds = (Date.now() - recordingStartTime) / 1000;
                recordingTimeElement.textContent = `${elapsedSeconds.toFixed(1)}s`;
                
                const maxTime = parseFloat(maxRecordingTimeInput.value);
                // S√≥ considerar o tempo m√°ximo se for maior que zero
                if (maxTime > 0) {
                    // Calcular porcentagem do tempo decorrido
                    const percentage = Math.min(100, (elapsedSeconds / maxTime) * 100);
                    recordingTimeBar.style.width = `${percentage}%`;
                    
                    // Mudar cor quando estiver pr√≥ximo do limite
                    if (percentage > 80) {
                        recordingTimeBar.style.backgroundColor = '#e74c3c'; // Vermelho quando pr√≥ximo do limite
                    } else if (percentage > 50) {
                        recordingTimeBar.style.backgroundColor = '#f39c12'; // Laranja no meio
                    } else {
                        recordingTimeBar.style.backgroundColor = '#3498db'; // Azul normal
                    }
                    
                    // Parar grava√ß√£o se atingiu o tempo m√°ximo
                    if (elapsedSeconds >= maxTime) {
                        log(`Tempo m√°ximo de grava√ß√£o de ${maxTime} segundos atingido. Parando grava√ß√£o.`, 'info');
                        stopRecording();
                    }
                } else {
                    // Se n√£o h√° tempo m√°ximo, apenas mostrar o tempo decorrido
                    recordingTimeBar.style.width = '0%';
                }
            }, 100);
        }

        // Fun√ß√£o para parar o timer de grava√ß√£o
        function stopRecordingTimer() {
            if (recordingTimer) {
                clearInterval(recordingTimer);
                recordingTimer = null;
            }
            recordingTimerContainer.style.display = 'none';
        }

        // Vari√°veis para a wake word
        let wakeWordWebsocket = null;
        let wakeWordEnabled = false;
        
        // Adicionar elementos para controle da wake word na interface
        function setupWakeWordInterface() {
            const settingsDiv = document.querySelector('.settings');
            
            // Criar a se√ß√£o de configura√ß√µes da wake word
            const wakeWordSection = document.createElement('div');
            wakeWordSection.style.marginTop = '15px';
            wakeWordSection.style.paddingTop = '10px';
            wakeWordSection.style.borderTop = '1px solid #ddd';
            
            // Criar toggle para ativar/desativar a wake word
            const wakeWordToggleDiv = document.createElement('div');
            wakeWordToggleDiv.style.display = 'flex';
            wakeWordToggleDiv.style.alignItems = 'center';
            wakeWordToggleDiv.style.justifyContent = 'space-between';
            
            const wakeWordLabel = document.createElement('label');
            wakeWordLabel.textContent = 'Ativar detec√ß√£o por wake word ("ma veee"):';
            
            const wakeWordSwitch = document.createElement('label');
            wakeWordSwitch.className = 'switch';
            wakeWordSwitch.innerHTML = `
                <input type="checkbox" id="wakeWordEnabled" checked>
                <span class="slider"></span>
            `;
            
            wakeWordToggleDiv.appendChild(wakeWordLabel);
            wakeWordToggleDiv.appendChild(wakeWordSwitch);
            
            // Adicionar status da conex√£o com o servidor de wake word
            const wakeWordStatusDiv = document.createElement('div');
            wakeWordStatusDiv.style.marginTop = '10px';
            wakeWordStatusDiv.innerHTML = `
                <div>Status da wake word: <span id="wakeWordStatus" style="color: #e74c3c; font-weight: bold;">Desconectado</span></div>
                <div style="margin-top: 5px; font-size: 12px; color: #7f8c8d;">Servidor em: ws://localhost:5678</div>
                
            `;
            
            // Adicionar os elementos √† se√ß√£o
            wakeWordSection.appendChild(wakeWordToggleDiv);
            wakeWordSection.appendChild(wakeWordStatusDiv);
            
            // Adicionar a se√ß√£o ao documento
            settingsDiv.appendChild(wakeWordSection);
            
            // Adicionar event listener para o toggle
            document.getElementById('wakeWordEnabled').addEventListener('change', function(e) {
                wakeWordEnabled = e.target.checked;
                if (wakeWordEnabled) {
                    connectToWakeWordServer();
                } else {
                    disconnectFromWakeWordServer();
                }
            });
        }
        
        // Adicionar vari√°vel para o som de confirma√ß√£o da wake word
        let wakeWordSound = new Audio('positive.wav');
        wakeWordSound.volume = 0.7; // Volume a 70%
        
        // Conectar ao servidor de wake word
        function connectToWakeWordServer() {
            if (wakeWordWebsocket && (wakeWordWebsocket.readyState === WebSocket.OPEN || 
                                     wakeWordWebsocket.readyState === WebSocket.CONNECTING)) {
                return; // J√° est√° conectado ou tentando conectar
            }
            
            try {
                log('Conectando ao servidor de wake word...', 'info');
                document.getElementById('wakeWordStatus').textContent = 'Conectando...';
                document.getElementById('wakeWordStatus').style.color = '#f39c12';
                
                wakeWordWebsocket = new WebSocket('ws://localhost:5678');
                
                wakeWordWebsocket.onopen = () => {
                    log('‚úÖ Conectado ao servidor de wake word', 'success');
                    document.getElementById('wakeWordStatus').textContent = 'Conectado';
                    document.getElementById('wakeWordStatus').style.color = '#27ae60';
                };
                
                wakeWordWebsocket.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        
                        if (data.event === 'wakeword_detected') {
                            log(`üéØ Wake word detectada! (Score: ${data.score.toFixed(3)})`, 'success');
                            
                            // Tocar som de confirma√ß√£o
                            try {
                                wakeWordSound.currentTime = 0; // Reinicia o √°udio
                                wakeWordSound.play()
                                    .catch(error => log(`Nota: N√£o foi poss√≠vel tocar o som de confirma√ß√£o: ${error.message}`, 'info'));
                            } catch (e) {
                                log(`Nota: Erro ao tocar som de confirma√ß√£o: ${e.message}`, 'info');
                            }
                            
                            // Verificar se j√° est√° gravando ou se estamos conectados ao servidor principal
                            if (!isRecording && (!websocket || websocket.readyState !== WebSocket.OPEN)) {
                                log('Iniciando grava√ß√£o autom√°tica ap√≥s detec√ß√£o da wake word', 'info');
                                // Simular clique no bot√£o de iniciar grava√ß√£o
                                connectAndStartRecording();
                            } else {
                                log('Ignorando wake word - j√° est√° gravando ou processando', 'info');
                            }
                        }
                    } catch (e) {
                        log(`Erro ao processar mensagem da wake word: ${e.message}`, 'error');
                    }
                };
                
                wakeWordWebsocket.onclose = () => {
                    log('Conex√£o com servidor de wake word fechada', 'info');
                    document.getElementById('wakeWordStatus').textContent = 'Desconectado';
                    document.getElementById('wakeWordStatus').style.color = '#e74c3c';
                    
                    // Tentar reconectar se estiver habilitado
                    if (wakeWordEnabled) {
                        setTimeout(() => {
                            if (wakeWordEnabled) {
                                log('Tentando reconectar ao servidor de wake word...', 'info');
                                connectToWakeWordServer();
                            }
                        }, 5000); // Aumentado para 5 segundos
                    }
                };
                
                wakeWordWebsocket.onerror = (error) => {
                    log(`Erro na conex√£o com servidor de wake word. Certifique-se que o servidor est√° rodando (python wakeword_server.py)`, 'error');
                    document.getElementById('wakeWordStatus').textContent = 'Erro';
                    document.getElementById('wakeWordStatus').style.color = '#e74c3c';
                };
                
            } catch (error) {
                log(`Erro ao conectar ao servidor de wake word: ${error.message}`, 'error');
                document.getElementById('wakeWordStatus').textContent = 'Erro';
                document.getElementById('wakeWordStatus').style.color = '#e74c3c';
            }
        }
        
        // Desconectar do servidor de wake word
        function disconnectFromWakeWordServer() {
            if (wakeWordWebsocket) {
                wakeWordWebsocket.close();
                wakeWordWebsocket = null;
                log('Desconectado do servidor de wake word', 'info');
            }
        }

        // Atualizar o window.addEventListener para incluir a configura√ß√£o da wake word
        window.addEventListener('load', async () => {
            log('P√°gina carregada. Verificando permiss√£o do microfone...', 'info');
            
            // Pr√©-carregar o som de confirma√ß√£o
            wakeWordSound.addEventListener('canplaythrough', () => {
                log('Som de confirma√ß√£o da wake word carregado', 'info');
            });
            
            wakeWordSound.addEventListener('error', (e) => {
                log(`Erro ao carregar o som de confirma√ß√£o: ${e.message || 'Arquivo n√£o encontrado'}. Verifique se o arquivo "positive.wav" existe no mesmo diret√≥rio.`, 'error');
            });
            
            // Adicionar interface para wake word
            setupWakeWordInterface();
            
            // Desabilitar o bot√£o de iniciar grava√ß√£o at√© que a permiss√£o seja concedida
            startBtn.disabled = true;
            
            // Solicitar permiss√£o do microfone ao carregar
            await requestMicrophonePermission();
            
            log('Clique em "Iniciar Grava√ß√£o" para come√ßar, ou aguarde a detec√ß√£o da wake word.', 'info');
            
            // Ativar wake word por padr√£o
            wakeWordEnabled = true;
            connectToWakeWordServer();
        });
    </script>
</body>
</html>